# ğŸ“˜ Day 11 - #15DaysOfDSAinJava

Welcome to Day 11 of my 15-day journey to master **Data Structures & Algorithms in Java**! ğŸš€  
Today was dedicated to one of the most essential algorithmic foundations â€” mastering different types of **Sorting Algorithms**.

---

## ğŸ“š Topics Covered:
- What is Sorting? Why do we need it?
- Bubble Sort â€“ Concept & Code
- Selection Sort â€“ Concept & Code
- Insertion Sort â€“ Concept & Code
- Javaâ€™s Inbuilt Sort â€“ Arrays.sort()
- Counting Sort â€“ Concept & Code

---

## ğŸ’» Problems Practiced:
- âœ… Manual dry runs of each sorting technique  
- âœ… Compared time and space complexities of Bubble, Selection & Insertion Sort  
- âœ… Implemented each algorithm from scratch in Java  
- âœ… Used Javaâ€™s built-in Arrays.sort() for optimized results  
- âœ… Learned Counting Sort for non-comparison-based linear sorting  
- âœ… Solved real-world style sorting problems and visualized array operations  

These practices gave me clarity on algorithm behavior, efficiency, and when to use which sorting approach based on data and constraints.

---

## ğŸ›  Tools Used:
- Java (VS Code)
- Arrays utility class for inbuilt sort
- Pen-paper dry runs for better visualization

---

## ğŸ” What's Inside:
Each sorting algorithm is implemented in its own .java file, with clear comments and outputs.  
Thereâ€™s a comparison of when and where to use different sorts, including edge cases and real-world data examples.

---

## ğŸ“Œ Key Takeaways:
- Bubble Sort: Simple but inefficient (O(nÂ²))  
- Selection Sort: Stable and predictable, also O(nÂ²)  
- Insertion Sort: Efficient for small or nearly sorted arrays  
- Arrays.sort(): Uses Dual-Pivot QuickSort â€” fast and reliable  
- Counting Sort: Linear time sorting for small integer ranges  
